/*
 * generated by Xtext
 */
package de.tubs.bibtextohtml.bibtex.validation

import de.tubs.bibtextohtml.bibtex.bibTeX.AddressField
import de.tubs.bibtextohtml.bibtex.bibTeX.AuthorField
import de.tubs.bibtextohtml.bibtex.bibTeX.BibTeXPackage
import de.tubs.bibtextohtml.bibtex.bibTeX.BooktitleField
import de.tubs.bibtextohtml.bibtex.bibTeX.EditionField
import de.tubs.bibtextohtml.bibtex.bibTeX.IsbnField
import de.tubs.bibtextohtml.bibtex.bibTeX.JournalField
import de.tubs.bibtextohtml.bibtex.bibTeX.MonthField
import de.tubs.bibtextohtml.bibtex.bibTeX.NoteField
import de.tubs.bibtextohtml.bibtex.bibTeX.NumberField
import de.tubs.bibtextohtml.bibtex.bibTeX.PagesField
import de.tubs.bibtextohtml.bibtex.bibTeX.PublisherField
import de.tubs.bibtextohtml.bibtex.bibTeX.SeriesField
import de.tubs.bibtextohtml.bibtex.bibTeX.TitleField
import de.tubs.bibtextohtml.bibtex.bibTeX.UnknownField
import de.tubs.bibtextohtml.bibtex.bibTeX.YearField
import org.eclipse.xtext.validation.Check
import de.tubs.bibtextohtml.bibtex.bibTeX.VolumeField
import de.tubs.bibtextohtml.bibtex.bibTeX.EditorField
import de.tubs.bibtextohtml.bibtex.bibTeX.OrganizationField
import de.tubs.bibtextohtml.bibtex.bibTeX.Article
import de.tubs.bibtextohtml.bibtex.bibTeX.BibtexEntryTypes
import de.tubs.bibtextohtml.bibtex.bibTeX.Conference
import de.tubs.bibtextohtml.bibtex.bibTeX.Inproceedings
import de.tubs.bibtextohtml.bibtex.bibTeX.Manual
import de.tubs.bibtextohtml.bibtex.bibTeX.Book
import de.tubs.bibtextohtml.bibtex.BibTeXTerminalConverters
import org.eclipse.emf.ecore.EObject
import de.tubs.bibtextohtml.bibtex.bibTeX.ArticleFields
import org.eclipse.emf.common.util.EList

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class BibTeXValidator extends AbstractBibTeXValidator {

	//  public static val INVALID_NAME = 'invalidName'
	//
	//	@Check
	//	def checkGreetingStartsWithCapital(Greeting greeting) {
	//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
	//			warning('Name should start with a capital', 
	//					MyDslPackage.Literals.GREETING__NAME,
	//					INVALID_NAME)
	//		}
	//	}
	public static val UNKNOWN_FIELD = 'UnknownField'
	public static val TITLE_FIELD = 'TitleField'

	@Check
	def checkForUnknowns(UnknownField unknown) {
		warning(
			'Field "' + unknown.getType().getType() + '" is unknown or not implemented yet. Hence it will be ignored.',
			BibTeXPackage.Literals.UNKNOWN_FIELD__TYPE, UNKNOWN_FIELD)
	}

	//Map for the mandatory fields of an article
	public static val articleMapMandatory = newHashMap('Author' -> AuthorField, 'Title' -> TitleField,
		'Journal' -> JournalField, 'Year' -> YearField)

	//Map for the optional fields of an article	
	public static val articleMapOptional = newHashMap('Volume' -> VolumeField, 'Number' -> NumberField,
		'Pages' -> PagesField, 'Month' -> MonthField, 'Note' -> NoteField)

	//Map for the mandatory fields of a book
	public static val bookMapMandatory = newHashMap('Author' -> AuthorField, 'Title' -> TitleField,
		'Publisher' -> PublisherField, 'Year' -> YearField)

	//Map for the optional fields of a book
	public static val bookMapOptional = newHashMap('Editor' -> EditorField, 'Volume' -> VolumeField,
		'Number' -> NumberField, 'Month' -> MonthField, 'Note' -> NoteField, 'Series' -> SeriesField,
		'Address' -> AddressField, 'Edition' -> EditionField, 'Isbn' -> IsbnField)

	//Map for the mandatory fields of a conference
	public static val conferenceMapMandatory = newHashMap('Author' -> AuthorField, 'Title' -> TitleField,
		'Booktitle' -> BooktitleField, 'Year' -> YearField)

	//Map for the optional fields of a conference	
	public static val conferenceMapOptional = newHashMap('Volume' -> VolumeField, 'Number' -> NumberField,
		'Pages' -> PagesField, 'Month' -> MonthField, 'Note' -> NoteField, 'Series' -> SeriesField,
		'Address' -> AddressField, 'Editor' -> EditorField, 'Organization' -> OrganizationField,
		'Publisher' -> PublisherField)

	//Map for the mandatory fields of a Inproceedings
	public static val inproceedingsMapMandatory = newHashMap('Author' -> AuthorField, 'Title' -> TitleField,
		'Booktitle' -> BooktitleField, 'Year' -> YearField)

	//Map for the optional fields of a Inproceedings	
	public static val inproceedingsMapOptional = newHashMap('Editor' -> EditorField, 'Volume' -> VolumeField,
		'Number' -> NumberField, 'Series' -> SeriesField, 'Pages' -> PagesField, 'Address' -> AddressField,
		'Month' -> MonthField, 'Organization' -> OrganizationField, 'Publisher' -> PublisherField, 'Note' -> NoteField)

	//Map for the mandatory fields of a manual
	public static val manualMapMandatory = newHashMap('Title' -> TitleField, 'Year' -> YearField,
		'Address' -> AddressField)

	//Map for the optional fields of a manual	
	public static val manualMapOptional = newHashMap('Author' -> AuthorField, 'Organization' -> OrganizationField,
		'Edition' -> EditionField, 'Month' -> MonthField, 'Note' -> NoteField)

	//	public static val entryMap = newHashMap('Article' -> Article, 'Book' -> Book, 'Conference' -> Conference,
	//		'Inproceedings' -> Inproceedings, 'Manual' -> Manual)
	def checkMultiple(String str, Class<? extends EObject> field, Iterable<? extends EObject> filteredList,
		EList<? extends EObject> completeList) {
		if (filteredList.size > 1) {
			filteredList.forEach [ duplicatedFields, i |
				completeList.forEach [ allFields, j |
					if (duplicatedFields.equals(allFields))
						warning(str + " is duplicated! The first one will be taken!",
							duplicatedFields.eContainmentFeature, j)
				]
			]
		}
	}

	@Check
	def checkForMultipleOccurence(Article article) {
		articleMapMandatory.forEach [ str, field |
			val filteredList = article.elements.filter(field);
			val unfilteredList = article.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
			if (filteredList.size == 0) {
				error(str + " is missing!", BibTeXPackage.Literals.BIBTEX_ENTRY_TYPES__KEY)
			}
		]

		articleMapOptional.forEach [ str, field |
			val filteredList = article.elements.filter(field);
			val unfilteredList = article.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
		]
	}

	@Check
	def checkForMultipleOccurence(Book book) {
		bookMapMandatory.forEach [ str, field |
			val filteredList = book.elements.filter(field);
			val unfilteredList = book.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
			if (filteredList.size == 0) {
				error(str + " is missing!", BibTeXPackage.Literals.BIBTEX_ENTRY_TYPES__KEY)
			}
		]

		bookMapOptional.forEach [ str, field |
			val filteredList = book.elements.filter(field);
			val unfilteredList = book.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
		]
	}

	@Check
	def checkForMultipleOccurence(Conference conference) {
		conferenceMapMandatory.forEach [ str, field |
			val filteredList = conference.elements.filter(field);
			val unfilteredList = conference.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
			if (filteredList.size == 0) {
				error(str + " is missing!", BibTeXPackage.Literals.BIBTEX_ENTRY_TYPES__KEY)
			}
		]

		conferenceMapOptional.forEach [ str, field |
			val filteredList = conference.elements.filter(field);
			val unfilteredList = conference.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
		]
	}

	@Check
	def checkForMultipleOccurence(Inproceedings inproceedings) {
		inproceedingsMapMandatory.forEach [ str, field |
			val filteredList = inproceedings.elements.filter(field);
			val unfilteredList = inproceedings.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
			if (filteredList.size == 0) {
				error(str + " is missing!", BibTeXPackage.Literals.BIBTEX_ENTRY_TYPES__KEY)
			}
		]

		inproceedingsMapOptional.forEach [ str, field |
			val filteredList = inproceedings.elements.filter(field);
			val unfilteredList = inproceedings.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
		]
	}

	@Check
	def checkForMultipleOccurence(Manual manual) {
		manualMapMandatory.forEach [ str, field |
			val filteredList = manual.elements.filter(field);
			val unfilteredList = manual.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
			if (filteredList.size == 0) {
				error(str + " is missing!", BibTeXPackage.Literals.BIBTEX_ENTRY_TYPES__KEY)
			}
		]

		manualMapOptional.forEach [ str, field |
			val filteredList = manual.elements.filter(field);
			val unfilteredList = manual.elements;
			checkMultiple(str, field, filteredList, unfilteredList);
		]
	}
}
